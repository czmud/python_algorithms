class Solution:
    def __init__(self):
        self.word_hash = {
            (0,0): 0
        }
    # memoized recursive top-down approach
    def minDistanceCaleb(self, word1, word2):
        len1 = len(word1)
        len2 = len(word2)
        state = (len1, len2)

        if state in self.word_hash:
            return self.word_hash[state]

        if len1 == 0 or len2 == 0:
            self.word_hash[state] = max(len1, len2)
        elif word1[0] == word2[0]:
            self.word_hash[state] = self.minDistanceCaleb(word1[1:], word2[1:])
        elif len1 == 1:
            if len2 == 1:
                self.word_hash[state] = 1
            elif word2.find(word1[0]) == -1:
                self.word_hash[state] = len2
            else:
                self.word_hash[state] = len2 - 1
        elif len2 == 1:
            if word1.find(word2[0]) == -1:
                self.word_hash[state] = len1
            else:
                self.word_hash[state] = len1 - 1
        else:
            i = self.minDistanceCaleb(word1, word2[1:])
            d = self.minDistanceCaleb(word1[1:], word2)
            r = self.minDistanceCaleb(word1[1:], word2[1:])
            self.word_hash[state] = 1 + min(i, d, r)

        return self.word_hash[state]

    # bottom-up iterable solution using n+1 x m+1 matrix
    def minDistanceErik(self, word1, word2):
        m = len(word1)
        n = len(word2)
        if m == 0: return n
        if n == 0: return m

        distances = [[0 for i in range(n+1)] for j in range(m+1)]
        for i in range(m+1):
            distances[i][0] = i
        for j in range(n+1):
            distances[0][j] = j

        for i in range(m):
            for j in range(n):
                if word1[i] == word2[j]:
                    distances[i+1][j+1] = distances[i][j]
                else:
                    distances[i+1][j+1] = 1 + min(distances[i][j], distances[i+1][j], distances[i][j+1])
        return distances

solution1 = Solution()


# comparison cases
solution1.minDistanceCaleb("cat","catcherblahs")
caleb_hash = solution1.word_hash
# modified return to give matrix generated by erik's solution
erik_distances = solution1.minDistanceErik("cat", "catcherblahs")
n = len(erik_distances)
m = len(erik_distances[0])

# build matrix of 0s equal in size to Erik's matrix
caleb_distances = [[0 for i in range(m)] for j in range(n)]

# for every position in matrix, check if equivalent entry exists in Caleb's hash
for j in range(n):
    for i in range(m):
        if (j, i) in caleb_hash:
            caleb_distances[j][i] = 1

# print Caleb's matrix
print("Caleb")
for row in caleb_distances:
    print(row)
print("Erik")
for row in erik_distances:
    print(row)

print(f'  len(caleb): {len(caleb_hash)}')
print(f'  len(erik) : {n*m}')

